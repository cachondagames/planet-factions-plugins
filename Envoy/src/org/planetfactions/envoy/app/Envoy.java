package org.planetfactions.envoy.app;

import java.util.ArrayList;
import java.util.Random;

import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.block.BlockFace;
import org.bukkit.entity.Player;

public class Envoy
{
	private ArrayList<Block> chestlocations = new ArrayList<Block>();
	private boolean DEBUGSTATE = false;
	private double OUTBOUND = 0;
	private double INBOUND = 0;
	private int DISTANCE = 10;
	private boolean ACTIVE = false;
	private static Envoy Envoy = new Envoy();
	private int NUMPLAYERSNEEDED = 1;
	private int AUTOSTARTCRATES = 5;
	private boolean PLAYERSREACHED = false;
	
	public void createEnvoy(Player p, int numcrates) // Initial call to spawn all the crates
	{	
		Location spawn = p.getWorld().getSpawnLocation(); // Gets world spawn
		ACTIVE = true;
		while(numcrates > 0)
		{
			double xVal = generateXValue();
			double zVal = generateZValue();
			Location temp = new Location(p.getWorld(), xVal, 100, zVal); // Generation of our random location in the world
			Location chest = spawn.add(temp); // Sets the location near the spawn within the bounds as defined by INBOUND and OUTBOUND
			double yVal = generateYValue(chest); // Makes sure the chest is on the ground **Possible bug with chest spawning in ground if the spawn is at y=100 or more**
			chest.setY(yVal);
			if(isLocationGood(chest.getBlock())) // Makes sure that the chest is location is within our bounds as defined by line 76 "10"
			{
				chestlocations.add(chooseTier(chest)); // Sets location to what ever tier as generated by chooseTier()
				numcrates--;
				if(DEBUGSTATE) // DEBUG
				{
					p.sendMessage(ChatColor.AQUA + "Placing" + chestlocations.get(chestlocations.size()-1).getType() + " at : " + chest.getBlockX() + " " + chest.getBlockY() + " " + chest.getBlockZ());
				}
			}				
		}	
	}
	
	public void createEnvoyServerStart(int numcrates) // Initial call to spawn all the crates
	{	
		Location spawn = Bukkit.getWorld("world").getSpawnLocation(); // Gets world spawn
		ACTIVE = true;
		while(numcrates > 0)
		{
			double xVal = generateXValue();
			double zVal = generateZValue();
			Location temp = new Location(Bukkit.getWorld("world"), xVal, 100, zVal); // Generation of our random location in the world
			Location chest = spawn.add(temp); // Sets the location near the spawn within the bounds as defined by INBOUND and OUTBOUND
			double yVal = generateYValue(chest); // Makes sure the chest is on the ground **Possible bug with chest spawning in ground if the spawn is at y=100 or more**
			chest.setY(yVal);
			if(isLocationGood(chest.getBlock())) // Makes sure that the chest is location is within our bounds as defined by line 76 "10"
			{
				chestlocations.add(chooseTier(chest)); // Sets location to what ever tier as generated by chooseTier()
				numcrates--;
				if(DEBUGSTATE) // DEBUG
				{
					System.out.println(ChatColor.AQUA + "Placing" + chestlocations.get(chestlocations.size()-1).getType() + " at : " + chest.getBlockX() + " " + chest.getBlockY() + " " + chest.getBlockZ());
				}
			}				
		}	
	}
	
	public Block chooseTier(Location l) // Randomly selects tiers 60:30:10 distribution with 100 over hang
	{
		Random ran1 = new Random();
		int num = ran1.nextInt(100) + 1;
		if(num < 60)
		{
			l.getBlock().setType(Material.CHEST);
			return l.getBlock();
		}
		else if(num >= 60 && num <= 90)
		{
			l.getBlock().setType(Material.ENDER_CHEST);
			return l.getBlock();
		}
		else
		{
			l.getBlock().setType(Material.BEACON);
			return l.getBlock();
		}
	}
	
	public boolean possibleLocations(int numcrates) // Calculates the possible amount of envoys that can be placed within 
	{
		int outboundarea = (int) Math.pow((OUTBOUND*2),2);
		int inboundarea = (int) Math.pow((INBOUND*2),2);
		int distancearea = (int) Math.pow((DISTANCE*2),2);
		int blkamount = outboundarea - inboundarea;
		if(blkamount/distancearea > numcrates)
		{
			if(DEBUGSTATE) // DEBUG
			{
				System.out.println("You are only able to spawn: " + blkamount/numcrates + " Crates");		
			}
			return true;
		}
		else
			if(DEBUGSTATE) // DEBUG
			{				
				System.out.println("You are only able to spawn: " + blkamount/numcrates + " Crates");
			}
			return false;
				
	}
	
	public boolean isLocationGood(Block b) // Logic for ensuring the location that is picked is within the bounds * Maybe make the bound be able to be set?*
	{
		if(chestlocations.size() == 1) // If the array only has one location or none will force a true to returned
			return true;
		else if(chestlocations.size() == 0)
			return true;	
		else
		{
			for(Block block : chestlocations)
			{
				if (block.getLocation().distance(b.getLocation()) < DISTANCE) // Using distance method to ensure no chest is within 10 blocks of each other
					return false;
			}
			if(b.getLocation().distance(Bukkit.getWorld("world").getSpawnLocation()) < INBOUND) // Using distance method to ensure that negative numbers dont cause our location to be set inside of our INBOUND
				return false;
			
			return true;
		}
	}
	
	public double generateXValue() // Logic to generate random X value 
	{
		int TempX = (int) Math.round((Math.random()*OUTBOUND+1)); // First call to generate random number then rounds up and casts as integer
		double xVal = 0;
		while(TempX <= INBOUND)
			TempX = (int) Math.round((Math.random()*OUTBOUND+1)); // Generates random number then rounds up and casts as integer in a loop until it satisfy's expression
		while(TempX > INBOUND)
		{
			if(Math.round(Math.random()*100+1) <= 50) // Logic to pick either the negative or positive value of the number as both will satisfy the INBOUND
			{
				xVal = TempX;
				return xVal;
			}
			else
			{
				xVal = TempX*-1;
				return xVal;
			}
		}
		return xVal;
	}
	
	public double generateZValue() // See Above
	{
		int TempZ = (int) Math.round((Math.random()*OUTBOUND+1));
		double zVal = 0;
		while(TempZ <= INBOUND)
			TempZ = (int) Math.round((Math.random()*OUTBOUND+1));
		while(TempZ > INBOUND)
		{
			if(Math.round((Math.random()*100+1)) <= 50)
			{
				zVal = TempZ;
				return zVal;
			}
			else
			{
				zVal = TempZ*-1;
				return zVal;
			}
		}
		return zVal;
	}
	
	public double generateYValue(Location l) // Logic to bring chest to ground *Will mostly likely need improvement*
	{
		while(l.getBlock().getRelative(BlockFace.DOWN).getType().equals(Material.AIR)) // Checks if the block below is air runs until it is not
		{
			l.setY(l.getY()-1);
		}
		return l.getY();
	}
	
	public void endEnvoy() //
	{
		for (Block location : chestlocations) // Removes chests that were spawned
		{
			location.setType(Material.AIR);
			if(getDebugState()) // DEBUG
				System.out.println("Removing Envoy at " + location.getX() + " " + location.getY() + " " + location.getZ());
		}
		chestlocations.clear(); // Reset chest list
		ACTIVE = false;
	}
		
	
	public boolean getDebugState() // Method to get our debug state
	{
		return DEBUGSTATE;
	}
	
	public void toggleDebugState() // Method to toggle debug on and off
	{
		if(getDebugState())
			DEBUGSTATE = false;
		else
			DEBUGSTATE = true;
	}

	public double getInnerBound() // Method to get our Inner Bound
	{
		return INBOUND;
	}

	public void setInnerBound(double inbound)  // Method to set our inner bound
	{
		INBOUND = inbound;
	}

	public double getOutterBound() // Method to get our outer bound
	{
		return OUTBOUND;
	}

	public void setOutterBound(double outbound) // Method to set our outer bound
	{
		OUTBOUND = outbound;
	}
	
	public boolean getEnvoyActiveState() // Method to get if an envoy is active or not
	{
		return ACTIVE;
	}
	
	public ArrayList<Block> getChestLocations() // Method to get chest locations
	{
		return chestlocations;
	}
	
	public void setDistance(int d) // Method to set our minimum distance
	{
		DISTANCE = d;
	}
	
	public int getDistance() // Method to get our minimum distance
	{
		return DISTANCE;
	}
	
	public static Envoy getEnvoyEvent() // Method to get our current envoy state
	{
		return Envoy;
	}

	public int getNumberPlayers() {
		return NUMPLAYERSNEEDED;
	}

	public void setNumberPlayers(int num) {
		NUMPLAYERSNEEDED = num;
	}
	
	public int getAutoStartCrates()
	{
		return AUTOSTARTCRATES;
	}
	
	public void setAutoStartCrates(int i)
	{
		AUTOSTARTCRATES = i;
	}
	
	public boolean getPlayersReached()
	{
		return PLAYERSREACHED;
	}
	
	public void setPlayersReached(boolean b)
	{
		PLAYERSREACHED = b;
	}
}
